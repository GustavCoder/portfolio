<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WeatherVue - Advanced Weather App</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #2c3e50;
            --accent-color: #3498db;
            --text-color: #2c3e50;
            --text-color-light: #7f8c8d;
            --background-color: #f5f7fa;
            --card-background: #ffffff;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        [data-theme="dark"] {
            --primary-color: #375a7f;
            --secondary-color: #1a2530;
            --accent-color: #2980b9;
            --text-color: #ecf0f1;
            --text-color-light: #bdc3c7;
            --background-color: #121212;
            --card-background: #1e1e1e;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            transition: var(--transition);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo h1 {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .search-bar {
            display: flex;
            width: 100%;
            max-width: 500px;
            position: relative;
        }

        .search-bar input {
            width: 100%;
            padding: 12px 20px;
            border: none;
            border-radius: 50px;
            background-color: var(--card-background);
            color: var(--text-color);
            font-size: 1rem;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .search-bar input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--primary-color);
        }

        .search-bar button {
            position: absolute;
            right: 5px;
            top: 5px;
            border: none;
            background-color: var(--primary-color);
            color: white;
            padding: 7px 15px;
            border-radius: 50px;
            cursor: pointer;
            transition: var(--transition);
        }

        .search-bar button:hover {
            background-color: var(--accent-color);
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .theme-toggle, .units-toggle {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-color);
            transition: var(--transition);
        }

        .theme-toggle:hover, .units-toggle:hover {
            color: var(--accent-color);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .current-weather {
            background-color: var(--card-background);
            border-radius: 20px;
            padding: 25px;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .current-weather-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .location {
            display: flex;
            flex-direction: column;
        }

        .location h2 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .location p {
            color: var(--text-color-light);
            font-size: 0.9rem;
        }

        .time {
            color: var(--text-color-light);
            font-size: 0.9rem;
        }

        .weather-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        .weather-icon {
            width: 100px;
            height: 100px;
            margin-bottom: 15px;
            position: relative;
        }

        .weather-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .temperature {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .weather-description {
            text-transform: capitalize;
            margin-bottom: 20px;
            font-size: 1.2rem;
        }

        .weather-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            width: 100%;
        }

        .detail-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: 10px;
            transition: var(--transition);
        }

        [data-theme="dark"] .detail-item {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .detail-item .label {
            font-size: 0.8rem;
            color: var(--text-color-light);
            margin-bottom: 5px;
        }

        .detail-item .value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .forecast-section {
            background-color: var(--card-background);
            border-radius: 20px;
            padding: 25px;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab-button {
            padding: 10px 20px;
            border: none;
            border-radius: 50px;
            background-color: rgba(0, 0, 0, 0.05);
            color: var(--text-color);
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
        }

        [data-theme="dark"] .tab-button {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .tab-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .hourly-forecast {
            display: flex;
            gap: 15px;
            overflow-x: auto;
            padding: 10px 0;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) transparent;
        }

        .hourly-forecast::-webkit-scrollbar {
            height: 6px;
        }

        .hourly-forecast::-webkit-scrollbar-track {
            background: transparent;
        }

        .hourly-forecast::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 6px;
        }

        .hour-item {
            min-width: 80px;
            padding: 15px 10px;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: var(--transition);
        }

        [data-theme="dark"] .hour-item {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .hour-item.current {
            background-color: rgba(74, 111, 165, 0.2);
        }

        [data-theme="dark"] .hour-item.current {
            background-color: rgba(74, 111, 165, 0.3);
        }

        .hour-item .time {
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .hour-item img {
            width: 40px;
            height: 40px;
            margin-bottom: 10px;
        }

        .hour-item .temp {
            font-weight: 600;
        }

        .daily-forecast {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .day-item {
            display: grid;
            grid-template-columns: 2fr 1fr 2fr;
            align-items: center;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: 10px;
            transition: var(--transition);
        }

        [data-theme="dark"] .day-item {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .day-item .day {
            font-weight: 600;
        }

        .day-item .icon-container {
            display: flex;
            justify-content: center;
        }

        .day-item img {
            width: 40px;
            height: 40px;
        }

        .day-item .temps {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            align-items: center;
        }

        .day-item .temp-max {
            font-weight: 600;
        }

        .day-item .temp-min {
            color: var(--text-color-light);
        }

        .chart-container {
            margin-top: 20px;
            height: 200px;
            position: relative;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background-color);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(74, 111, 165, 0.2);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .error-message {
            background-color: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
            opacity: 0;
            transform: translateY(-20px);
            transition: var(--transition);
        }

        .error-message.active {
            opacity: 1;
            transform: translateY(0);
        }

        .additional-sections {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .section-card {
            background-color: var(--card-background);
            border-radius: 20px;
            padding: 25px;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .section-card h3 {
            margin-bottom: 15px;
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .alerts-container {
            max-height: 200px;
            overflow-y: auto;
        }

        .alert-item {
            padding: 15px;
            border-radius: 10px;
            background-color: rgba(231, 76, 60, 0.1);
            margin-bottom: 10px;
            border-left: 3px solid #e74c3c;
        }

        .alert-item h4 {
            margin-bottom: 5px;
            color: #e74c3c;
        }

        .alert-item p {
            font-size: 0.9rem;
            color: var(--text-color);
        }

        .alert-item .alert-time {
            font-size: 0.8rem;
            color: var(--text-color-light);
            margin-top: 5px;
        }

        .map-container {
            height: 300px;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .weather-map {
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.1);
        }

        #weather-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            header {
                flex-direction: column;
                gap: 15px;
            }
            
            .search-bar {
                max-width: 100%;
            }
            
            .controls {
                margin-top: 10px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            .current-weather, .forecast-section, .section-card {
                padding: 15px;
            }
            
            .temperature {
                font-size: 2.5rem;
            }
            
            .weather-details {
                grid-template-columns: 1fr;
            }
        }

        /* Animation keyframes */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease forwards;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        .location-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            margin-left: 10px;
            transition: var(--transition);
        }

        .location-btn:hover {
            background-color: var(--accent-color);
        }

        .search-controls {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="loading">
        <div class="spinner"></div>
        <p>Loading WeatherVue...</p>
    </div>

    <div class="container">
        <header>
            <div class="logo">
                <svg width="30" height="30" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 3V5M5.6 6.6L7 8M3 12H5M5.6 17.4L7 16M18.4 17.4L17 16M21 12H19M18.4 6.6L17 8M12 19V21M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <h1>WeatherVue</h1>
            </div>
            <div class="search-controls">
                <div class="search-bar">
                    <input type="text" id="search-input" placeholder="Search for a city...">
                    <button id="search-button">Search</button>
                </div>
                <button class="location-btn" id="location-button" title="Use current location">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 8C9.79 8 8 9.79 8 12C8 14.21 9.79 16 12 16C14.21 16 16 14.21 16 12C16 9.79 14.21 8 12 8ZM20.94 11C20.48 6.83 17.17 3.52 13 3.06V2C13 1.45 12.55 1 12 1C11.45 1 11 1.45 11 2V3.06C6.83 3.52 3.52 6.83 3.06 11H2C1.45 11 1 11.45 1 12C1 12.55 1.45 13 2 13H3.06C3.52 17.17 6.83 20.48 11 20.94V22C11 22.55 11.45 23 12 23C12.55 23 13 22.55 13 22V20.94C17.17 20.48 20.48 17.17 20.94 13H22C22.55 13 23 12.55 23 12C23 11.45 22.55 11 22 11H20.94ZM12 19C8.13 19 5 15.87 5 12C5 8.13 8.13 5 12 5C15.87 5 19 8.13 19 12C19 15.87 15.87 19 12 19Z" fill="currentColor"/>
                    </svg>
                </button>
            </div>
            <div class="controls">
                <button class="units-toggle" id="units-toggle" title="Change temperature units">°C</button>
                <button class="theme-toggle" id="theme-toggle" title="Toggle dark mode">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8V16Z" fill="currentColor"/>
                        <path d="M12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2ZM12 4V8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16V20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4Z" fill="currentColor"/>
                    </svg>
                </button>
            </div>
        </header>

        <div class="error-message" id="error-message">
            Error message will appear here
        </div>

        <div class="main-content">
            <div class="current-weather">
                <div class="current-weather-header">
                    <div class="location">
                        <h2 id="location-name">Loading...</h2>
                        <p id="location-country"></p>
                    </div>
                    <div class="time" id="current-time"></div>
                </div>
                <div class="weather-display">
                    <div class="weather-icon">
                        <img id="weather-icon" alt="Weather icon">
                        <canvas id="animation-canvas" class="weather-canvas"></canvas>
                    </div>
                    <div class="temperature" id="current-temp">--°</div>
                    <div class="weather-description" id="weather-description">Loading weather data</div>
                    <div class="weather-details">
                        <div class="detail-item">
                            <div class="label">Feels Like</div>
                            <div class="value" id="feels-like">--°</div>
                        </div>
                        <div class="detail-item">
                            <div class="label">Humidity</div>
                            <div class="value" id="humidity">--%</div>
                        </div>
                        <div class="detail-item">
                            <div class="label">Wind</div>
                            <div class="value" id="wind-speed">-- km/h</div>
                        </div>
                        <div class="detail-item">
                            <div class="label">Pressure</div>
                            <div class="value" id="pressure">-- hPa</div>
                        </div>
                    </div>
                </div>
            </div>
                
                <div class="tab-content active" id="hourly-tab">
                    <div class="hourly-forecast" id="hourly-forecast">
                        <!-- Hourly forecast items will be added here -->
                    </div>
                    <div class="chart-container">
                        <canvas id="hourly-chart"></canvas>
                    </div>
                </div>
                
                <div class="tab-content" id="daily-tab">
                    <div class="daily-forecast" id="daily-forecast">
                        <!-- Daily forecast items will be added here -->
                    </div>
                    <div class="chart-container">
                        <canvas id="daily-chart"></canvas>
                    </div>
                </div>
                
                <div class="tab-content" id="details-tab">
                    <div class="chart-container">
                        <canvas id="details-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="additional-sections">
            <div class="section-card">
                <h3>Weather Alerts</h3>
                <div class="alerts-container" id="alerts-container">
                    <p id="no-alerts-msg">No active weather alerts for this location.</p>
                </div>
            </div>

            <div class="section-card">
                <h3>Weather Map</h3>
                <div class="map-container">
                    <div id="weather-map" class="weather-map"></div>
                    <canvas id="weather-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // API key
        const API_KEY = '7651b7958992dee59e37fd94305f76d6';
        
        // DOM elements
        const loadingElement = document.querySelector('.loading');
        const errorMessageElement = document.getElementById('error-message');
        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-button');
        const locationButton = document.getElementById('location-button');
        const themeToggle = document.getElementById('theme-toggle');
        const unitsToggle = document.getElementById('units-toggle');
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // App state
        let state = {
            units: 'metric', // 'metric' for Celsius, 'imperial' for Fahrenheit
            theme: 'light',  // 'light' or 'dark'
            weatherData: null,
            forecastData: null,
            charts: {
                hourly: null,
                daily: null,
                details: null
            },
            location: {
                lat: null,
                lon: null,
                name: null,
                country: null
            },
            animations: {}
        };

        // Initialize the app
        function initApp() {
            setupEventListeners();
            loadSavedPreferences();
            getUserLocation();
        }

        // Set up event listeners
        function setupEventListeners() {
            searchButton.addEventListener('click', handleSearch);
            searchInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') handleSearch();
            });
            locationButton.addEventListener('click', getUserLocation);
            themeToggle.addEventListener('click', toggleTheme);
            unitsToggle.addEventListener('click', toggleUnits);
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabName = button.getAttribute('data-tab');
                    switchTab(tabName);
                });
            });

            window.addEventListener('resize', () => {
                if (state.weatherData) {
                    updateCharts();
                }
            });
        }

        // Load saved preferences from localStorage
        function loadSavedPreferences() {
            const savedTheme = localStorage.getItem('weathervue-theme');
            const savedUnits = localStorage.getItem('weathervue-units');
            
            if (savedTheme) {
                state.theme = savedTheme;
                applyTheme();
            }
            
            if (savedUnits) {
                state.units = savedUnits;
                updateUnitsDisplay();
            }
        }

        // Handle search
        function handleSearch() {
            const query = searchInput.value.trim();
            if (query.length > 0) {
                showLoading();
                geocodeLocation(query);
            }
        }

        // Get user's current location
        function getUserLocation() {
            if (navigator.geolocation) {
                showLoading();
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        state.location.lat = position.coords.latitude;
                        state.location.lon = position.coords.longitude;
                        fetchWeatherData();
                    },
                    (error) => {
                        hideLoading();
                        showError(`Location error: ${error.message}. Please search for a city instead.`);
                    }
                );
            } else {
                showError("Geolocation is not supported by your browser. Please search for a city instead.");
            }
        }

        // Geocode a location name to coordinates
        function geocodeLocation(query) {
            fetch(`https://api.openweathermap.org/geo/1.0/direct?q=${query}&limit=1&appid=${API_KEY}`)
                .then(response => response.json())
                .then(data => {
                    if (data.length > 0) {
                        state.location.lat = data[0].lat;
                        state.location.lon = data[0].lon;
                        state.location.name = data[0].name;
                        state.location.country = data[0].country;
                        fetchWeatherData();
                    } else {
                        hideLoading();
                        showError("Location not found. Please try another search term.");
                    }
                })
                .catch(error => {
                    hideLoading();
                    showError("Error finding location: " + error.message);
                });
        }

        // Fetch current weather and forecast data
        function fetchWeatherData() {
            const { lat, lon } = state.location;
            const units = state.units;
            
            // Fetch current weather
            fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=${units}&appid=${API_KEY}`)
                .then(response => response.json())
                .then(weatherData => {
                    state.weatherData = weatherData;
                    state.location.name = weatherData.name;
                    state.location.country = weatherData.sys.country;
                    
                    // Fetch forecast data
                    return fetch(`https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&units=${units}&appid=${API_KEY}`);
                })
                .then(response => response.json())
                .then(forecastData => {
                    state.forecastData = forecastData;
                    
                    // Fetch one call API for daily forecast and alerts
                    return fetch(`https://api.openweathermap.org/data/3.0/onecall?lat=${lat}&lon=${lon}&units=${units}&exclude=minutely&appid=${API_KEY}`);
                })
                .then(response => response.json())
                .then(oneCallData => {
                    // Update UI with all fetched data
                    updateUI(oneCallData);
                    hideLoading();
                })
                .catch(error => {
                    hideLoading();
                    showError("Error fetching weather data: " + error.message);
                });
        }

        // Update the UI with weather data
        function updateUI(oneCallData) {
            const { weatherData, forecastData } = state;
            
            // Update current weather
            document.getElementById('location-name').textContent = state.location.name;
            document.getElementById('location-country').textContent = state.location.country;
            document.getElementById('current-time').textContent = formatDate(new Date(), 'time');
            document.getElementById('current-temp').textContent = `${Math.round(weatherData.main.temp)}°`;
            document.getElementById('weather-description').textContent = weatherData.weather[0].description;
            document.getElementById('feels-like').textContent = `${Math.round(weatherData.main.feels_like)}°`;
            document.getElementById('humidity').textContent = `${weatherData.main.humidity}%`;
            document.getElementById('wind-speed').textContent = `${Math.round(weatherData.wind.speed)} ${state.units === 'metric' ? 'km/h' : 'mph'}`;
            document.getElementById('pressure').textContent = `${weatherData.main.pressure} hPa`;
            
            // Update weather icon
            const weatherIcon = document.getElementById('weather-icon');
            weatherIcon.src = `https://openweathermap.org/img/wn/${weatherData.weather[0].icon}@2x.png`;
            weatherIcon.alt = weatherData.weather[0].description;
            
            // Update hourly forecast
            if (forecastData && forecastData.list) {
                updateHourlyForecast(forecastData.list.slice(0, 8));
            } else {
                // Handle the missing data appropriately
                console.error("Forecast data is missing or invalid");
            }
            
            // Update daily forecast if we have data
            if (oneCallData && oneCallData.daily) {
                updateDailyForecast(oneCallData.daily);
            }
            
            // Update weather alerts
            if (oneCallData && oneCallData.alerts) {
                updateWeatherAlerts(oneCallData.alerts);
            } else {
                // Clear alerts if there are none
                updateWeatherAlerts([]);
            }
            
            // Generate charts
            generateCharts(forecastData, oneCallData);
            
            // Start weather animations
            startWeatherAnimations(weatherData.weather[0].id);
            
            // Apply fade-in animation to the UI elements
            document.querySelectorAll('.current-weather, .forecast-section, .section-card').forEach(el => {
                el.classList.add('fade-in');
            });
        }

        // Update hourly forecast
        function updateHourlyForecast(hourlyData) {
            const hourlyForecastContainer = document.getElementById('hourly-forecast');
            hourlyForecastContainer.innerHTML = '';
            
            const currentHour = new Date().getHours();
            
            hourlyData.forEach((item, index) => {
                const time = new Date(item.dt * 1000);
                const hour = time.getHours();
                const temp = Math.round(item.main.temp);
                const iconCode = item.weather[0].icon;
                
                const hourlyItem = document.createElement('div');
                hourlyItem.className = 'hour-item';
                if (index === 0) {
                    hourlyItem.classList.add('current');
                }
                
                hourlyItem.innerHTML = `
                    <div class="time">${formatHour(hour)}</div>
                    <img src="https://openweathermap.org/img/wn/${iconCode}.png" alt="${item.weather[0].description}">
                    <div class="temp">${temp}°</div>
                `;
                
                hourlyForecastContainer.appendChild(hourlyItem);
            });
        }

        // Update daily forecast
        function updateDailyForecast(dailyData) {
            const dailyForecastContainer = document.getElementById('daily-forecast');
            dailyForecastContainer.innerHTML = '';
            
            dailyData.slice(0, 7).forEach((day, index) => {
                const date = new Date(day.dt * 1000);
                const dayName = formatDay(date, index);
                const iconCode = day.weather[0].icon;
                const tempMax = Math.round(day.temp.max);
                const tempMin = Math.round(day.temp.min);
                
                const dayItem = document.createElement('div');
                dayItem.className = 'day-item';
                
                dayItem.innerHTML = `
                    <div class="day">${dayName}</div>
                    <div class="icon-container">
                        <img src="https://openweathermap.org/img/wn/${iconCode}.png" alt="${day.weather[0].description}">
                    </div>
                    <div class="temps">
                        <span class="temp-max">${tempMax}°</span>
                        <span class="temp-min">${tempMin}°</span>
                    </div>
                `;
                
                dailyForecastContainer.appendChild(dayItem);
            });
        }

        // Update weather alerts
        function updateWeatherAlerts(alerts) {
            const alertsContainer = document.getElementById('alerts-container');
            const noAlertsMsg = document.getElementById('no-alerts-msg');
            
            alertsContainer.innerHTML = '';
            
            if (alerts && alerts.length > 0) {
                noAlertsMsg.style.display = 'none';
                
                alerts.forEach(alert => {
                    const alertItem = document.createElement('div');
                    alertItem.className = 'alert-item';
                    
                    const startTime = new Date(alert.start * 1000);
                    const endTime = new Date(alert.end * 1000);
                    
                    alertItem.innerHTML = `
                        <h4>${alert.event}</h4>
                        <p>${alert.description}</p>
                        <div class="alert-time">
                            ${formatDate(startTime, 'datetime')} - ${formatDate(endTime, 'datetime')}
                        </div>
                    `;
                    
                    alertsContainer.appendChild(alertItem);
                });
            } else {
                alertsContainer.appendChild(noAlertsMsg);
                noAlertsMsg.style.display = 'block';
            }
        }

        // Generate weather charts
        function generateCharts(forecastData, oneCallData) {
            const hourlyChartCtx = document.getElementById('hourly-chart').getContext('2d');
            const dailyChartCtx = document.getElementById('daily-chart').getContext('2d');
            const detailsChartCtx = document.getElementById('details-chart').getContext('2d');
            
            // Destroy existing charts if they exist
            if (state.charts.hourly) state.charts.hourly.destroy();
            if (state.charts.daily) state.charts.daily.destroy();
            if (state.charts.details) state.charts.details.destroy();
            
            // Prepare data for hourly temperature chart
            const hourlyLabels = forecastData.list.slice(0, 8).map(item => formatHour(new Date(item.dt * 1000).getHours()));
            const hourlyTemps = forecastData.list.slice(0, 8).map(item => item.main.temp);
            
            // Create hourly chart
            state.charts.hourly = new Chart(hourlyChartCtx, {
                type: 'line',
                data: {
                    labels: hourlyLabels,
                    datasets: [{
                        label: 'Temperature',
                        data: hourlyTemps,
                        fill: true,
                        backgroundColor: 'rgba(74, 111, 165, 0.2)',
                        borderColor: 'rgba(74, 111, 165, 1)',
                        tension: 0.3,
                        pointBackgroundColor: 'rgba(74, 111, 165, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${Math.round(context.raw)}°${state.units === 'metric' ? 'C' : 'F'}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            ticks: {
                                callback: function(value) {
                                    return `${Math.round(value)}°`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Prepare data for daily temperature chart
            const dailyLabels = oneCallData.daily.slice(0, 7).map((day, index) => formatDay(new Date(day.dt * 1000), index, true));
            const dailyMaxTemps = oneCallData.daily.slice(0, 7).map(day => day.temp.max);
            const dailyMinTemps = oneCallData.daily.slice(0, 7).map(day => day.temp.min);
            
            // Create daily chart
            state.charts.daily = new Chart(dailyChartCtx, {
                type: 'line',
                data: {
                    labels: dailyLabels,
                    datasets: [
                        {
                            label: 'Max Temperature',
                            data: dailyMaxTemps,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            fill: false,
                            tension: 0.3,
                            pointBackgroundColor: 'rgba(255, 99, 132, 1)'
                        },
                        {
                            label: 'Min Temperature',
                            data: dailyMinTemps,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            fill: false,
                            tension: 0.3,
                            pointBackgroundColor: 'rgba(54, 162, 235, 1)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${Math.round(context.raw)}°${state.units === 'metric' ? 'C' : 'F'}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            ticks: {
                                callback: function(value) {
                                    return `${Math.round(value)}°`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Prepare data for detail chart (humidity, pressure, etc)
            const detailLabels = oneCallData.hourly.slice(0, 24).map((hour, index) => index === 0 ? 'Now' : `+${index}h`);
            const humidityData = oneCallData.hourly.slice(0, 24).map(hour => hour.humidity);
            const pressureData = oneCallData.hourly.slice(0, 24).map(hour => (hour.pressure - 990) * 2); // Normalize pressure data
            
            // Create details chart
            state.charts.details = new Chart(detailsChartCtx, {
                type: 'line',
                data: {
                    labels: detailLabels,
                    datasets: [
                        {
                            label: 'Humidity (%)',
                            data: humidityData,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            fill: true,
                            yAxisID: 'y',
                            tension: 0.3,
                            pointBackgroundColor: 'rgba(75, 192, 192, 1)'
                        },
                        {
                            label: 'Pressure (hPa)',
                            data: pressureData,
                            borderColor: 'rgba(153, 102, 255, 1)',
                            backgroundColor: 'rgba(153, 102, 255, 0.2)',
                            fill: true,
                            yAxisID: 'y1',
                            tension: 0.3,
                            pointBackgroundColor: 'rgba(153, 102, 255, 1)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Humidity (%)'
                            },
                            min: 0,
                            max: 100
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Pressure (hPa)'
                            },
                            min: 0,
                            max: 100,
                            grid: {
                                drawOnChartArea: false
                            },
                            ticks: {
                                callback: function(value) {
                                    return ((value / 2) + 990) + ' hPa';
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.label === 'Pressure (hPa)') {
                                        return `Pressure: ${(context.raw / 2) + 990} hPa`;
                                    }
                                    return `Humidity: ${context.raw}%`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Start weather animations based on weather condition
        function startWeatherAnimations(weatherId) {
            const canvas = document.getElementById('animation-canvas');
            const ctx = canvas.getContext('2d');
            
            // Clear any existing animations
            if (state.animations.interval) {
                clearInterval(state.animations.interval);
            }
            
            // Set canvas dimensions
            canvas.width = 100;
            canvas.height = 100;
            
            // Define particles array for animations
            const particles = [];
            
            // Weather animations based on OpenWeatherMap condition codes
            if (weatherId >= 200 && weatherId < 300) {
                // Thunderstorm
                createThunderstormAnimation(ctx, particles);
            } else if (weatherId >= 300 && weatherId < 400) {
                // Drizzle
                createDrizzleAnimation(ctx, particles);
            } else if (weatherId >= 500 && weatherId < 600) {
                // Rain
                createRainAnimation(ctx, particles);
            } else if (weatherId >= 600 && weatherId < 700) {
                // Snow
                createSnowAnimation(ctx, particles);
            } else if (weatherId >= 700 && weatherId < 800) {
                // Atmosphere (fog, mist etc)
                createFogAnimation(ctx, particles);
            } else if (weatherId === 800) {
                // Clear sky
                createClearSkyAnimation(ctx, particles);
            } else if (weatherId > 800) {
                // Clouds
                createCloudyAnimation(ctx, particles);
            }
        }

        // Thunderstorm animation
        function createThunderstormAnimation(ctx, particles) {
            // Add rain
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: Math.random() * 100,
                    y: Math.random() * 50,
                    length: 10 + Math.random() * 10,
                    speed: 15 + Math.random() * 5
                });
            }
            
            let flash = false;
            let flashTimer = 0;
            
            state.animations.interval = setInterval(() => {
                ctx.clearRect(0, 0, 100, 100);
                
                // Draw clouds
                ctx.fillStyle = '#919191';
                ctx.beginPath();
                ctx.arc(30, 30, 20, 0, Math.PI * 2);
                ctx.arc(50, 25, 15, 0, Math.PI * 2);
                ctx.arc(70, 30, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Lightning flash
                flashTimer++;
                if (flashTimer > 50 && Math.random() > 0.9) {
                    flash = true;
                    flashTimer = 0;
                }
                
                if (flash) {
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.7)';
                    ctx.fillRect(0, 0, 100, 100);
                    flash = false;
                    
                    // Draw lightning bolt
                    ctx.strokeStyle = '#fffc00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(50, 40);
                    ctx.lineTo(45, 60);
                    ctx.lineTo(55, 65);
                    ctx.lineTo(50, 85);
                    ctx.stroke();
                }
                
                // Draw rain
                ctx.strokeStyle = '#99ccff';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < particles.length; i++) {
                    ctx.beginPath();
                    ctx.moveTo(particles[i].x, particles[i].y);
                    ctx.lineTo(particles[i].x, particles[i].y + particles[i].length);
                    ctx.stroke();
                    
                    particles[i].y += particles[i].speed;
                    
                    if (particles[i].y > 100) {
                        particles[i].y = Math.random() * -20;
                        particles[i].x = Math.random() * 100;
                    }
                }
                
            }, 30);
        }

        // Drizzle animation
        function createDrizzleAnimation(ctx, particles) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: Math.random() * 100,
                    y: Math.random() * 50,
                    length: 5 + Math.random() * 5,
                    speed: 5 + Math.random() * 3
                });
            }
            
            state.animations.interval = setInterval(() => {
                ctx.clearRect(0, 0, 100, 100);
                
                // Draw clouds
                ctx.fillStyle = '#b5b5b5';
                ctx.beginPath();
                ctx.arc(30, 30, 20, 0, Math.PI * 2);
                ctx.arc(50, 25, 15, 0, Math.PI * 2);
                ctx.arc(70, 30, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw drizzle
                ctx.strokeStyle = 'rgba(153, 204, 255, 0.6)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < particles.length; i++) {
                    ctx.beginPath();
                    ctx.moveTo(particles[i].x, particles[i].y);
                    ctx.lineTo(particles[i].x, particles[i].y + particles[i].length);
                    ctx.stroke();
                    
                    particles[i].y += particles[i].speed;
                    
                    if (particles[i].y > 100) {
                        particles[i].y = Math.random() * -20;
                        particles[i].x = Math.random() * 100;
                    }
                }
                
            }, 30);
        }

        // Rain animation
        function createRainAnimation(ctx, particles) {
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: Math.random() * 100,
                    y: Math.random() * 50,
                    length: 7 + Math.random() * 7,
                    speed: 10 + Math.random() * 5
                });
            }
            
            state.animations.interval = setInterval(() => {
                ctx.clearRect(0, 0, 100, 100);
                
                // Draw clouds
                ctx.fillStyle = '#6b6b6b';
                ctx.beginPath();
                ctx.arc(30, 30, 20, 0, Math.PI * 2);
                ctx.arc(50, 25, 15, 0, Math.PI * 2);
                ctx.arc(70, 30, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw rain
                ctx.strokeStyle = '#6bb9ff';
                ctx.lineWidth = 1.5;
                
                for (let i = 0; i < particles.length; i++) {
                    ctx.beginPath();
                    ctx.moveTo(particles[i].x, particles[i].y);
                    ctx.lineTo(particles[i].x, particles[i].y + particles[i].length);
                    ctx.stroke();
                    
                    particles[i].y += particles[i].speed;
                    
                    if (particles[i].y > 100) {
                        particles[i].y = Math.random() * -20;
                        particles[i].x = Math.random() * 100;
                    }
                }
                
            }, 30);
        }

        // Snow animation
        function createSnowAnimation(ctx, particles) {
            for (let i = 0; i < 40; i++) {
                particles.push({
                    x: Math.random() * 100,
                    y: Math.random() * 50,
                    size: 1 + Math.random() * 3,
                    speed: 1 + Math.random() * 2,
                    wind: Math.random() * 0.5 - 0.25
                });
            }
            
            state.animations.interval = setInterval(() => {
                ctx.clearRect(0, 0, 100, 100);
                
                // Draw clouds
                ctx.fillStyle = '#a8a8a8';
                ctx.beginPath();
                ctx.arc(30, 30, 20, 0, Math.PI * 2);
                ctx.arc(50, 25, 15, 0, Math.PI * 2);
                ctx.arc(70, 30, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw snow
                ctx.fillStyle = '#ffffff';
                
                for (let i = 0; i < particles.length; i++) {
                    ctx.beginPath();
                    ctx.arc(particles[i].x, particles[i].y, particles[i].size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    particles[i].y += particles[i].speed;
                    particles[i].x += particles[i].wind;
                    
                    // Snow wiggle
                    if (Math.random() > 0.8) {
                        particles[i].x += Math.random() * 0.5 - 0.25;
                    }
                    
                    if (particles[i].y > 100) {
                        particles[i].y = Math.random() * -20;
                        particles[i].x = Math.random() * 100;
                    }
                    
                    if (particles[i].x < 0) particles[i].x = 100;
                    if (particles[i].x > 100) particles[i].x = 0;
                }
                
            }, 30);
        }

        // Fog animation
        function createFogAnimation(ctx, particles) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: Math.random() * 120 - 10,
                    y: 30 + Math.random() * 40,
                    width: 30 + Math.random() * 40,
                    speed: 0.2 + Math.random() * 0.2,
                    opacity: 0.3 + Math.random() * 0.3
                });
            }
            
            state.animations.interval = setInterval(() => {
                ctx.clearRect(0, 0, 100, 100);
                
                // Draw fog
                for (let i = 0; i < particles.length; i++) {
                    const gradient = ctx.createLinearGradient(
                        particles[i].x, 
                        particles[i].y, 
                        particles[i].x + particles[i].width, 
                        particles[i].y
                    );
                    gradient.addColorStop(0, `rgba(200, 200, 200, 0)`);
                    gradient.addColorStop(0.5, `rgba(200, 200, 200, ${particles[i].opacity})`);
                    gradient.addColorStop(1, `rgba(200, 200, 200, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(particles[i].x, particles[i].y, particles[i].width, 8);
                    
                    particles[i].x += particles[i].speed;
                    
                    if (particles[i].x > 110) {
                        particles[i].x = -30;
                        particles[i].y = 30 + Math.random() * 40;
                    }
                }
                
            }, 30);
        }

        // Clear sky animation
        function createClearSkyAnimation(ctx, particles) {
            const sunY = 30;
            let sunRadius = 20;
            let growing = false;
            
            // Add some stars for twinkling
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: Math.random() * 100,
                    y: Math.random() * 20,
                    size: 1 + Math.random(),
                    opacity: 0.5,
                    fadeDirection: Math.random() > 0.5 ? 1 : -1
                });
            }
            
            state.animations.interval = setInterval(() => {
                ctx.clearRect(0, 0, 100, 100);
                
                // Gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, 100);
                gradient.addColorStop(0, '#8ec9ff');
                gradient.addColorStop(1, '#c0deff');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 100, 100);
                
                // Draw sun with glow
                const sunGradient = ctx.createRadialGradient(
                    50, sunY, sunRadius * 0.5,
                    50, sunY, sunRadius * 1.5
                );
                sunGradient.addColorStop(0, '#ffeb3b');
                sunGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.5)');
                sunGradient.addColorStop(1, 'rgba(255, 235, 59, 0)');
                
                ctx.fillStyle = sunGradient;
                ctx.beginPath();
                ctx.arc(50, sunY, sunRadius * 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.arc(50, sunY, sunRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Pulse animation for sun
                if (growing) {
                    sunRadius += 0.05;
                    if (sunRadius > 21) growing = false;
                } else {
                    sunRadius -= 0.05;
                    if (sunRadius < 20) growing = true;
                }
                
                // Draw stars (if dark theme)
                if (state.theme === 'dark') {
                    for (let i = 0; i < particles.length; i++) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${particles[i].opacity})`;
                        ctx.beginPath();
                        ctx.arc(particles[i].x, particles[i].y, particles[i].size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Twinkle effect
                        particles[i].opacity += 0.02 * particles[i].fadeDirection;
                        
                        if (particles[i].opacity > 1) {
                            particles[i].opacity = 1;
                            particles[i].fadeDirection = -1;
                        } else if (particles[i].opacity < 0.3) {
                            particles[i].opacity = 0.3;
                            particles[i].fadeDirection = 1;
                        }
                    }
                }
                
            }, 30);
        }

        // Cloudy animation
        function createCloudyAnimation(ctx, particles) {
            // Create clouds that move slowly
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: i * 40 - 10,
                    y: 30 + i * 5,
                    speed: 0.2 + Math.random() * 0.1,
                    size: 15 + Math.random() * 10
                });
            }
            
            state.animations.interval = setInterval(() => {
                ctx.clearRect(0, 0, 100, 100);
                
                // Gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, 100);
                gradient.addColorStop(0, '#b0d0f0');
                gradient.addColorStop(1, '#d0e0f0');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 100, 100);
                
                // Draw clouds
                ctx.fillStyle = '#ffffff';
                
                for (let i = 0; i < particles.length; i++) {
                    ctx.beginPath();
                    ctx.arc(particles[i].x, particles[i].y, particles[i].size, 0, Math.PI * 2);
                    ctx.arc(particles[i].x + particles[i].size, particles[i].y, particles[i].size * 0.8, 0, Math.PI * 2);
                    ctx.arc(particles[i].x + particles[i].size * 0.5, particles[i].y - particles[i].size * 0.4, particles[i].size * 0.9, 0, Math.PI * 2);
                    ctx.arc(particles[i].x - particles[i].size * 0.5, particles[i].y - particles[i].size * 0.2, particles[i].size * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Move clouds
                    particles[i].x += particles[i].speed;
                    
                    // Reset position when cloud moves off screen
                    if (particles[i].x > 120) {
                        particles[i].x = -30;
                    }
                }
                
            }, 30);
        }

        // Toggle theme between light and dark
        function toggleTheme() {
            state.theme = state.theme === 'light' ? 'dark' : 'light';
            applyTheme();
            localStorage.setItem('weathervue-theme', state.theme);
        }

        // Apply the current theme to the UI
        function applyTheme() {
            if (state.theme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeToggle.innerHTML = `
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM12 20C7.59 20 4 16.41 4 12C4 7.59 7.59 4 12 4C16.41 4 20 7.59 20 12C20 16.41 16.41 20 12 20ZM12 6C8.69 6 6 8.69 6 12C6 15.31 8.69 18 12 18V6Z" fill="currentColor"/>
                    </svg>
                `;
            } else {
                document.documentElement.removeAttribute('data-theme');
                themeToggle.innerHTML = `
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8V16Z" fill="currentColor"/>
                        <path d="M12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2ZM12 4V8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16V20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4Z" fill="currentColor"/>
                    </svg>
                `;
            }
            
            // Update charts with theme colors if they exist
            updateCharts();
        }

        // Toggle temperature units between Celsius and Fahrenheit
        function toggleUnits() {
            state.units = state.units === 'metric' ? 'imperial' : 'metric';
            updateUnitsDisplay();
            localStorage.setItem('weathervue-units', state.units);
            
            // Update weather data with new units
            if (state.location.lat && state.location.lon) {
                showLoading();
                fetchWeatherData();
            }
        }

        // Update the units display in the UI
        function updateUnitsDisplay() {
            unitsToggle.textContent = state.units === 'metric' ? '°C' : '°F';
        }

        // Switch between tabs
        function switchTab(tabName) {
            // Update active class on tab buttons
            tabButtons.forEach(button => {
                if (button.getAttribute('data-tab') === tabName) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
            
            // Show the selected tab content
            tabContents.forEach(content => {
                if (content.id === `${tabName}-tab`) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });
            
            // If switching to daily or details tab, make sure charts are properly sized
            if (tabName === 'daily' || tabName === 'details') {
                if (state.charts[tabName]) {
                    setTimeout(() => {
                        state.charts[tabName].resize();
                    }, 10);
                }
            }
        }

        // Update charts when theme changes
        function updateCharts() {
            if (!state.charts.hourly) return;
            
            const chartBgColor = state.theme === 'dark' ? '#1e1e1e' : '#ffffff';
            const chartTextColor = state.theme === 'dark' ? '#ecf0f1' : '#2c3e50';
            
            Chart.defaults.color = chartTextColor;
            
            const updateChartColors = (chart) => {
                if (!chart) return;
                chart.options.scales.x.grid.color = state.theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                chart.options.scales.y.grid.color = state.theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                if (chart.options.scales.y1) {
                    chart.options.scales.y1.grid.color = state.theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                }
                chart.update();
            };
            
            updateChartColors(state.charts.hourly);
            updateChartColors(state.charts.daily);
            updateChartColors(state.charts.details);
        }

        // Utility: Format date according to the specified format
        function formatDate(date, format) {
            const options = { 
                hour: 'numeric', 
                minute: '2-digit',
                hour12: true
            };
            
            if (format === 'datetime') {
                options.month = 'short';
                options.day = 'numeric';
            }
            
            return new Intl.DateTimeFormat('en-US', options).format(date);
        }

        // Utility: Format hour for display
        function formatHour(hour) {
            const period = hour >= 12 ? 'PM' : 'AM';
            const formattedHour = hour % 12 || 12;
            return `${formattedHour} ${period}`;
        }

        // Utility: Format day for display
        function formatDay(date, index, short = false) {
            const today = new Date();
            const tomorrow = new Date();
            tomorrow.setDate(today.getDate() + 1);
            
            if (index === 0) {
                return 'Today';
            } else if (index === 1) {
                return 'Tomorrow';
            } else {
                const options = { weekday: short ? 'short' : 'long' };
                return new Intl.DateTimeFormat('en-US', options).format(date);
            }
        }

        // Show loading screen
        function showLoading() {
            loadingElement.classList.remove('hidden');
        }

        // Hide loading screen
        function hideLoading() {
            loadingElement.classList.add('hidden');
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>